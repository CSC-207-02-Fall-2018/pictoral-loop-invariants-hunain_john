Problem 1)
ANSWER

Problem 2)
Output from testing Partition.java:
[2, 1, 3, 4, 6, 5]	MID: 2
[5, 3, 2, 4, 1, 6]	MID: 5
[1, 5, 2, 4, 3, 6]	MID: 0
[4, 1, 2, 5, 6, 5]	MID: 3
[3, 1, 2, 4, 6, 5]	MID: 4
[3]	MID: 0
[5, 6]	MID: 1

Why its right: It performed the correct partition for the parameters we
gave it on arrays of multiple sizes and degrees of sorting. We therefore
believe that it works, especially on the edge case of array of size 2.

Problem 3)
Part of the output from testing Median.java for select:
First array: 
Smallest1:1
Smallest2:2
Smallest3:3
Smallest4:4
Smallest5:5
Smallest6:6

Second array: 
Smallest1:1
Smallest2:2
Smallest3:3
Smallest4:4
Smallest5:5
Smallest6:6

Why its right: In a array containing the values 1-6, the nth smallest value
is equal to n, which is what this testing shows us. We tested this on two
arrays with different ordering, therefore we are confident that it works. 
Problem 4)
TESTING

Problem 5)
Output from testing Quicksort.java:
[1]
[1, 2]
[1, 2, 3]
[1, 3, 7, 8]
[1, 2, 3, 7, 8]
[2, 3, 4, 4, 7, 8]

Why its right: All of the input arrays (as seen in main method) were of
various lengths and degrees of sorting before quicksort was run on them. We
can see that they are all now sorted, thus we believe that the method
works.

Problem 6)
(first means leftmost)
Invariant B
lastWhite = index of last examined white value 
firstBlue = index of first blue value (examined) 
lastRed = index of the last examined red value (examined)
  

Invariant C
lastRed = index of last red value
firstWhite = index of first white value
firstBlue = index of first blue value 

Problem 9)
Testing of both methods: 